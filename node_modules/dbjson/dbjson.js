    var DBVERSION       = '1.0.2';
    var dbFs            = require('fs');

    var dbRedis         = require('redis'),
    dbClientRedis       = dbRedis.createClient(),
    dbUnder             = require('underscore'),
    dbCrypto            = require('crypto'),
    dbShasum            = dbCrypto.createHash('sha1');

    var dbInstances     = {};
    var dbBag           = {};
    var dbBuffer        = [];

    var DbConfig = function () {
        this.set = function(key, value) {
            dbBag[key] = value;
        };

        this.get = function(key, defaultValue) {
            if (this.has(key)) {
                return dbBag[key];
            }

            return defaultValue;
        };

        this.has = function (key) {
            return typeof(dbBag[key]) !== 'undefined';
        };

        this.forget = function (key) {
            if (this.has(key)) {
                remove(dbBag[key]);
            }
        };
    };

    var Dbjson = function (database, table) {
        var instance = dbInstances[database + '::' + table];

        if  (typeof(instance) === 'function') {
            return instance;
        }

        var conf        = new DbConfig;

        this.db         = database;
        this.table      = table;
        this.env        = conf.get('env');
        this.storageDir = conf.get('storageDir') + '/' + 'dbjson';

        this.directory  = this.storageDir + '/' + database + '_' + this.env + '/' + table;

        this.results    = [];
        this.wheres     = [];
        this.lastInsertId = null;

        this.pk = function() {
            return 'id';
        };

        this.save = function(data) {
            if (typeof(data.id) !== 'undefined') {
                return this.update(data);
            } else {
                return this.create(data);
            }
        };

        this.create = function (data) {
            data.created_at = data.updated_at = this.ts();

            var db = this;

            return this.makeId(function (newId) {
                var key = db.sha1(db.directory) + 'indexes';
                var fileExists = true;
                var file = db.directory + '/' + newId + '.row';

                var nextId = parseInt(newId);

                while (true === fileExists) {
                    fileExists = dbFs.existsSync(file);

                    if (true === fileExists) {
                        var nextId = nextId + 1;
                        file = db.directory + '/' + nextId + '.row';
                        db.cache().incr(key);
                    }
                }

                db.lastInsertId = data.id = nextId;

                dbFs.writeFileSync(file, JSON.stringify(data), "utf8");

                return db.find(nextId);
            });
        };

        this.update = function (data) {
            var file = this.directory + '/' + data.id + '.row';

            data.updated_at = this.ts();

            var exists = dbFs.existsSync(file);

            if (exists) {
                var oldData = dbFs.readFileSync(file);
                var jsonOld = JSON.parse(data);

                var dataUpdated = this.mergeData(jsonOld, data);
                dbFs.unlinkSync(file);
            } else {
                var dataUpdated = data;
            }

            dbFs.writeFileSync(file, JSON.stringify(dataUpdated), "utf8");

            return db.find(nextId);
        };

        this.delete = function (id) {
            var file = this.directory + '/' + id + '.row';

            var exists = dbFs.existsSync(file);

            if (exists) {
                return dbFs.unlinkSync(file);
            }

            return false;
        };

        this.all = function() {
            var collection = [];
            var files = dbFs.readdirSync(this.directory);

            if (files.length > 0) {
                for (key in files) {
                    var file = files[key];
                    collection.push(this.storageDir + '/' + database + '_' + this.env + '/' + table + '/' + file);
                }
            }

            return collection;
        };

        this.fetch = function () {
            this.results = this.all();

            return this;
        };

        this.full = function () {
            this.results = this.all();

            return this;
        };

        this.execute = function () {
            return this.make();
        };

        this.make = function () {
            var collection = [], exists, file, row, data, i;

            if (this.results.length > 0) {
                for (i = 0; i < this.results.length; i++) {
                    file = this.results[i];
                    exists = dbFs.existsSync(file);

                    if (exists) {
                        data = dbFs.readFileSync(file);
                        row = JSON.parse(data);

                        collection.push(row);
                    }
                }
            }

            this.clean();

            return collection;
        };

        this.groupBy = function(field) {
            var groupBys = [];
            var ever = [];

            if (this.results.length == 0) {
                return this;
            }

            for (var i = 0; i < this.results.length; i++) {
                var file = this.results[i];
                var exists = dbFs.existsSync(file);

                if (exists) {
                    var data = dbFs.readFileSync(file);
                    var row = JSON.parse(data);

                    var value = this.ake(row, field, null);

                    if (!this.inArray(value, ever)) {
                        groupBys[index] = row;
                        ever.push(value);
                    }
                }
            }

            this.results = this.sort(field, 'ASC', groupBys);

            return this;
        };

        this.sortBy = function(field, reverse, primer) {
            var key = function (x) {return primer ? primer(x[field]) : x[field]};

            return function (a,b) {
                var A = key(a), B = key(b);
                return ( (A < B) ? -1 : ((A > B) ? 1 : 0) ) * [-1,1][+!!reverse];
            };
        };

        this.sort = function (field, direction, collection) {
            var self = this;
            if (typeof(direction) === 'undefined') direction = 'ASC';

            var applyToResults = true;

            if (typeof(collection) === 'undefined') {
                collection = this.make();
            } else {
                applyToResults = false;
            }

            if (collection.length > 0) {
                var firstRow = collection[0];
                var compareInt = !isNaN(firstRow[field]);

                if (true === compareInt) {
                    if ('ASC' == direction) {
                        collection.sort(this.sortBy(field, true, parseInt));
                    } else {
                        collection.sort(this.sortBy(field, false, parseInt));
                    }
                } else {

                    if ('ASC' == direction) {
                        collection.sort(this.sortBy(field, true, function(a){return a.toUpperCase();}));
                    } else {
                        collection.sort(this.sortBy(field, false, function(a){return a.toUpperCase();}));
                    }
                }
            }

            if (false === applyToResults) {
                return collection;
            } else {
                if (collection.length > 0) {
                    var newCollection = [];

                    for (key in collection) {
                        var row = collection[key];
                        var id = row.id;
                        newCollection.push(this.directory + '/' + id + '.row');
                    }

                    this.results = newCollection;
                }

                return this;
            }
        };

        this.sum = function(field) {
            var sum = 0;

            if (this.results.length < 1) {
                return sum;
            }

            for (var i = 0; i < this.results.length; i++) {
                var file = this.results[i];
                var exists = dbFs.existsSync(file);

                if (exists) {
                    var data = dbFs.readFileSync(file);
                    var row = JSON.parse(data);

                    var value = this.ake(row, field, null);

                    if (null !== value) {
                        value = parseInt(value);
                        sum += value;
                    }
                }
            }

            this.clean();

            return sum;
        };

        this.avg = function (field) {
            var avg = 0;

            if (this.results.length < 1) {
                return avg;
            }
            var storeResults = this.results;

            var sum = this.sum(field);

            return (parseInt(sum) / parseInt(storeResults.length));
        };

        this.min = function (field) {
            var first = true;
            var min = 0;

            if (this.results.length > 0) {
                for (var i = 0; i < this.results.length; i++) {
                    var file = this.results[i];
                    var exists = dbFs.existsSync(file);

                    if (exists) {
                        var data = dbFs.readFileSync(file);
                        var row = JSON.parse(data);

                        var val = this.ake(row, field, 0);

                        if (true === first) {
                            min = val;
                        } else {
                            min = val < min ? val : min;
                        }

                        first = false;
                    }
                }
            }

            this.clean();

            return min;
        };

        this.max = function (field) {
            var first = true;
            var max = 0;

            if (this.results.length > 0) {
                for (var i = 0; i < this.results.length; i++) {
                    var file = this.results[i];
                    var exists = dbFs.existsSync(file);

                    if (exists) {
                        var data = dbFs.readFileSync(file);
                        var row = JSON.parse(data);

                        var val = this.ake(row, field, 0);

                        if (true === first) {
                            max = val;
                        } else {
                            max = val > max ? val : max;
                        }

                        first = false;
                    }
                }
            }

            this.clean();

            return max;
        };

        this.getLastId = function () {
            return this.lastInsertId;
        };

        this.count = function() {
            return this.results.length;
        };

        this.countAll = function() {
            return this.all().length;
        };

        this.limit = function (limit, offset) {
            if (typeof(offset) === 'undefined') offset = 0;
            limit = parseInt(limit);
            offset = parseInt(offset);
            offset = this.results.length < offset ? this.results.length : offset;
            this.results = this.results.slice(offset, offset + limit);

            return this;
        };

        this.intersect = function(a, b) {
            var results = [];

            if (a.length < 1 || b.length < 1) {
                return results;
            }

            var aIds = [];

            for (var key in a) {
                var id = a[key].split('/' + this.table + '/')[1].split('.row')[0];
                aIds[id] = true;
            }

            for (var key in b) {
                var row = b[key];
                var id = b[key].split('/' + this.table + '/')[1].split('.row')[0];
                var exists = this.ake(aIds, id, false);

                if (exists) {
                    results.push(row);
                }
            }

            return results;
        };

        this.merge = function (a, b) {
            if (a.length == 0) {
                return b;
            }

            if (b.length == 0) {
                return a;
            }

            var results = [];
            var aIds = [];

            for (var key in a) {
                var id = a[key].split('/' + this.table + '/')[1].split('.row')[0];
                aIds[id] = true;
                results.push(row);
            }

            for (var key in b) {
                var row = b[key];
                var id = b[key].split('/' + this.table + '/')[1].split('.row')[0];
                var exists = this.ake(aIds, id, false);

                if (!exists) {
                    results.push(row);
                }
            }

            return results;
        };

        this.where = function (condition, op) {
            var first = this.wheres.length < 1;

            if (typeof(op) === 'undefined') op = 'AND';

            var research = this.search(condition);

            if (false === first) {
                if (op == 'AND') {
                    this.results = this.intersect(this.results, research);
                } else {
                    this.results = this.merge(this.results, research);
                }
            } else {
                this.results = research;
            }

            this.wheres.push(condition);

            return this;
        };

        this.search = function(condition) {
            if (typeof(condition) === 'undefined') condition = null;

            var datas = this.all();

            if (null === condition) return datas;
            if (datas.length == 0) return datas;

            condition  = condition.split('NOT LIKE').join('NOTLIKE');
            condition  = condition.split('NOT IN').join('NOTIN');
            condition  = condition.split('LIKE START').join('LIKESTART');
            condition  = condition.split('LIKE END').join('LIKEEND');

            var tab     = condition.split(' ');
            var field   = tab[0];
            var op      = tab[1];
            var value   = tab[2];

            var collection = [];

            for (var key in datas) {
                var file = datas[key];
                var exists = dbFs.existsSync(file);

                if (exists) {
                    var data = dbFs.readFileSync(file);
                    var row = JSON.parse(data);

                    var val = this.ake(row, field, null);

                    if (null !== val) {
                        var check = this.compare(val, op, value);
                    } else {
                        var check = ('null' == value) ? true : false;
                    }

                    if (true === check) {
                        collection.push(file);
                    }
                }
            }

            return collection;
        };

        this.compare = function (comp, op, value) {
            if (typeof(comp) === 'string') comp = comp.toLowerCase();
            if (typeof(value) === 'string') value = value.toLowerCase();

            if (typeof(comp) === 'number') {
                value = parseInt(value);
            }

            var res = false;

            if (null !== comp) {
                switch (op) {
                    case '=':
                        if (typeof(comp) === 'number') {
                            res = comp == value;
                        } else {
                            res = this.sha1(comp) == this.sha1(value);
                        }
                        break;
                    case '>=':
                        res = comp >= value;
                        break;
                    case '>':
                        res = comp > value;
                        break;
                    case '<':
                        res = comp < value;
                        break;
                    case '<=':
                        res = comp <= value;
                        break;
                    case '<>':
                    case '!=':
                        res = this.sha1(comp) != this.sha1(value);
                        break;
                    case 'LIKE':
                        value = value.split("'").join('');
                        value = value.split("%").join('*');

                        res = this.fnmatch(value, comp);
                        break;
                    case 'NOTLIKE':
                        value = value.split("'").join('');
                        value = value.split("%").join('*');

                        res = !this.fnmatch(value, comp);
                        break;
                    case 'LIKESTART':
                        value = value.split("'").join('');
                        value = value.split("%").join('*');

                        res = this.fnmatch(value, comp);
                        break;
                    case 'LIKEEND':
                        value = value.split("'").join('');
                        value = value.split("%").join('*');

                        res = !this.fnmatch(value, comp);
                        break;
                    case 'IN':
                        value = value.split("(").join('');
                        value = value.split(")").join('');
                        var tabValues = value.split(',');

                        res = this.inArray(comp, tabValues);
                        break;
                    case 'NOTIN':
                        value = value.split("(").join('');
                        value = value.split(")").join('');
                        var tabValues = value.split(',');

                        res = !this.inArray(comp, tabValues);
                        break;
                }
            }
            return res;
        };

        this.findBy = function (field, value, one) {
            if (typeof(one) === 'undefined') one = false;
            var res = this.search(field + ' = '+ value);

            if (true === one) {
                var file = this.results.length > 0 ? this.results[0] : false;

                if (false !== file) {
                    var exists = dbFs.existsSync(file);

                    if (exists) {
                        var data = dbFs.readFileSync(file);
                        var row = JSON.parse(data);

                        return row;
                    } else {
                        return {};
                    }
                }

            } else {
                return this.make();
            }
        };

        this.find = function (id) {
            var file = this.directory + '/' + id + '.row';

            var exists = dbFs.existsSync(file);

            if (exists) {
                var data = dbFs.readFileSync(file);
                var row = JSON.parse(data);

                return row;
            } else {
                return {};
            }
        };

        this.findOneBy = function(field, value) {
            return this.findBy(field, value, true);
        };

        this.clean = function () {
            this.results = [];
            this.wheres = [];
            this.lastInsertId = null;
        };

        this.first = function () {
            var res = this.results;
            this.reset();
            return res.length > 0 ? res[0] : {};
        };

        this.last = function () {
            var res = this.results;
            this.reset();
            return res.length > 0 ? res[res.length - 1] : {};
        };

        this.inArray = function (needle, haystack) {
            var length = haystack.length;
            for(var i = 0; i < length; i++) {
                if(haystack[i] == needle) return true;
            }
            return false;
        };

        this.mergeData = function(oldData, newData) {
            var preparedData = {};

            Object.keys(newData).forEach(function(key) {
                preparedData[key] = newData[key];
            });

            Object.keys(oldData).forEach(function(key) {
                if (typeof(preparedData[key]) === 'undefined') {
                    preparedData[key] = oldData[key];
                }
            });

            return preparedData;
        };

        this.makeId = function (cb) {
            var key = this.sha1(this.directory) + 'indexes';

            this.cache().incr(key, function (err, val) {
                if (typeof(cb) === 'function') cb(val);
            });
        };

        this.ake = function (obj, key, defaultValue) {
            if (typeof(defaultValue) === 'undefined') defaultValue = null;
            return typeof(obj[key]) === 'undefined' ? defaultValue : obj[key];
        };

        this.cache = function() {
            return dbClientRedis;
        };

        this.sha1 = function (str) {
            var crypto = require('crypto');
            var shasum = crypto.createHash('sha1');
            shasum.update(str);

            return shasum.digest('hex');
        };

        this.ts = function() {
            return Math.round(new Date().getTime() / 1000);
        };

        this.serialize = function (mixedValue) {
            var val, key, okey, ktype = '', vals = '', count = 0,
            _utf8Size = function(str) {
                var size = 0,
                i = 0,
                l = str.length,
                code = '';

                for (i = 0; i < l; i++) {
                    code = str.charCodeAt(i);
                    if (code < 0x0080) {
                        size += 1;
                    } else if (code < 0x0800) {
                        size += 2;
                    } else {
                        size += 3;
                    }
                }

                return size;
            };

            _getType = function(inp) {
                var match, key, cons, types, type = typeof inp;

                if (type === 'object' && !inp) {
                    return 'null';
                }

                if (type === 'object') {
                    if (!inp.constructor) {
                        return 'object';
                    }

                    cons = inp.constructor.toString();
                    match = cons.match(/(\w+)\(/);

                    if (match) {
                        cons = match[1].toLowerCase();
                    }

                    types = ['boolean', 'number', 'string', 'array'];

                    for (key in types) {
                        if (cons == types[key]) {
                            type = types[key];
                            break;
                        }
                    }
                }

                return type;
            };

            type = _getType(mixedValue);

            switch (type) {
                case 'function':
                    val = '';
                    break;
                case 'boolean':
                    val = 'b:' + (mixedValue ? '1' : '0');
                    break;
                case 'number':
                    val = (Math.round(mixedValue) == mixedValue ? 'i' : 'd') + ':' + mixedValue;
                    break;
                case 'string':
                    val = 's:' + _utf8Size(mixedValue) + ':"' + mixedValue + '"';
                    break;
                case 'array':
                case 'object':
                    val = 'a';

                    for (key in mixedValue) {
                        if (mixedValue.hasOwnProperty(key)) {
                            ktype = _getType(mixedValue[key]);
                            if (ktype === 'function') {
                                continue;
                            }

                            okey = (key.match(/^[0-9]+$/) ? parseInt(key, 10) : key);
                            vals += this.serialize(okey) + this.serialize(mixedValue[key]);
                            count++;
                        }
                    }

                    val += ':' + count + ':{' + vals + '}';
                    break;
                case 'undefined':
                default:
                    val = 'N';
                    break;
            }

            if (type !== 'object' && type !== 'array') {
                val += ';';
            }

            return val;
        }

        this.fnmatch = function (pattern, string) {
            var res = new RegExp(pattern.split('*').join('.*')).test(string);

            return res;
        };

        this.strtr = function (str, from, to) {
            var fr = '',
            i = 0,
            j = 0,
            lenStr = 0,
            lenFrom = 0,
            tmpStrictForIn = false,
            fromTypeStr = '',
            toTypeStr = '',
            istr = '';
            var tmpFrom = [];
            var tmpTo = [];
            var ret = '';
            var match = false;

            lenStr = str.length;
            lenFrom = from.length;
            fromTypeStr = typeof from === 'string';
            toTypeStr = typeof to === 'string';

            for (i = 0; i < lenStr; i++) {
                match = false;
                if (fromTypeStr) {
                    istr = str.charAt(i);
                    for (j = 0; j < lenFrom; j++) {
                        if (istr == from.charAt(j)) {
                            match = true;
                            break;
                        }
                    }
                } else {
                    for (j = 0; j < lenFrom; j++) {
                        if (str.substr(i, from[j].length) == from[j]) {
                            match = true;
                            i = (i + from[j].length) - 1;
                            break;
                        }
                    }
                }

                if (match) {
                    ret += toTypeStr ? to.charAt(j) : to[j];
                } else {
                    ret += str.charAt(i);
                }
            }

            return ret;
        };

        dbInstances[database + '::' + table] = this;
    };

    // var conf = new DbConfig;

    // conf.set('env', 'development');
    // conf.set('storageDir', '/var/www/zelift/app/storage/zelift');

    // var db = new Dbjson('zelift', 'people');

    // var res = db.where('name = barbieri').where('firstname LIKE %i%').sort('firstname', 'DESC').make();
    // var res = db.where('name = barbieri').where('firstname LIKE %i%').sort('firstname', 'DESC').count();
    // var res = db.where('name = barbieri').where('firstname LIKE %i%').sum('id');
    // var res = db.where('name = barbieri').where('firstname LIKE %i%').avg('id');
    // var res = db.where('name = barbieri').where('firstname LIKE %i%').min('id');
    // var res = db.where('name = barbieri').where('firstname LIKE %i%').max('id');

    // var res = db.where('name = barbieri').where('firstname LIKE %i%').sort('firstname', 'DESC').limit(1).make();

    // var res = db.save({name: 'testnom', 'firstname': 'testpre'});

    // console.log(res);

    if (typeof (module) !== "undefined") {
        module.exports = exports = DbConfig;
        module.exports = exports = Dbjson;
    }
